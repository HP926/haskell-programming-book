9.1 Lists

Lists do double duty in Haskell. 
The first purpose lists serve is as a 
way to refer to and process a collection 
or plurality of values. The second is as 
an infinite series of values, usually 
generated by a function, which allows 
them to act as a stream datatype.


9.2 The list datatype

```
data[]a=[]| a:[a]
```

(:) `cons` infix operator


9.3 Pattern matching on lists

Using Maybe

Defining a type signature with "Maybe" allows
for nothing to be used


9.4 List’s syntactic sugar

```
[1, 2, 3] ++ [4] == (1 : 2 : 3 : []) ++ 4 : []
```


9.5 Using ranges to construct lists

```
[1..10]
enumFromThenTo 1 2 10
[2,4..10]
['t'..'z']
```

Exercise: EnumFromTo
EnumFromTo.hs 


9.6 Extracting portions of lists

```
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
```

9.7 List comprehensions

```
[ x^2 | x <- [1..10]]
```
1. This is the output function that will apply to the 
members of the list we indicate.
2. The pipe here designates the separation 
between the output function and the input.
3. This is the input set: a generator list and a 
variable that represents the elements that will 
be drawn from that list. This says, 
“from a list of numbers from 1-10, take (<-) each element as an
input to the output function.”


Adding predicates

```
[x^2 | x <- [1..10], rem x 2 == 0]
```

comma after generator list and add condition

```
[x^y | x <- [1..5], y <- [2, 3]]
```

multiple generators, right most first


Adding predicates

```
Prelude> [x^2 | x <- [1..10], rem x 2 == 0]
```

predicates must end evalate to Bool values

Exercises: Comprehend Thy Lists

Take a look at the following functions, 
figure what you think the output lists will 
be, and then run them in your REPL to verify 
(note that you will need the mySqr list from above 
in scope to do this):

let mySqr = [x^2 | x <- [1..10]]


1. [x | x <- mySqr, rem x 2 == 0]

evaluates mySqr [1,4,9,16,25,36,49,64,81,100]
loops through each element
if even adds it to the new list

[4,16,36,64,100]


2.[(x, y) | x <- mySqr,
          y <- mySqr,
          x < 50, y > 50]

evaluates mySqr [1,4,9,16,25,36,49,64,81,100] for two lists
loops trough both lists one by one
if the x element is < 50, x gets added to to first element in tuple
the y element in the tuple cannot be asssigned until y > 50 is true


[ (1,64),(1,81),(1,100),(4,64),(4,81)
, (4,100),(9,64),(9,81),(9,100),(16,64)
,(16,81),(16,100),(25,64),(25,81),(25,100)
,(36,64),(36,81),(36,100),(49,64)
,(49,81),(49,100)
]

3. take 5 [ (x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50 ]

same as above exept on the first 5 element are returned

[ (1,64),(1,81),(1,100),(4,64),(4,81)]

List comprehensions with Strings

[x | x <- "Three Letter Acronym", elem x ['A'..'Z']]

new list        starting list         condition


Exercises: Square Cube

Given the following:

Prelude> let mySqr = [x^2 | x <- [1..5]]
Prelude> let myCube = [y^3 | y <- [1..5]]

1. First write an expression that will make 
tuples of the outputs of mySqr and myCube.

[(x, y) | x <- mySqr, y <- myCube ]

2. Now alter that expression so that it only 
uses the x and y values that are less than 50.

[(x, y) | x <- mySqr, y <- myCube, x < 50, y < 50 ]

3. Apply another function to that list comprehension to determine
how many tuples inhabit your output list.

length [(x, y) | x <- mySqr, y <- myCube, x < 50, y < 50 ]

9.8 Spines and nonstrict evaluation

In the case of a list, the spine is usually textually 
represented by the recursive cons (:) operators. 
Given the data: [1, 2, 3], we get a list that looks like:

1 : 2 : 3 : []
or
1 : (2 : (3 : []))


Haskell’s evaluation is nonstrict, the list 
isn’t constructed until it’s consumed — indeed, 
nothing is evaluated until it must be. Until it’s 
consumed or you force strictness in some way, 
there are a series of placeholders as a blueprint o
f the list that can be constructed when it’s needed


Using GHCi’s :sprint command

:sprint command shows evaluated values

```
Prelude> let blah = enumFromTo 'a' 'z'
Prelude> :sprint blah
blah = _
```

```
Prelude> take 1 blah
"a"
Prelude> :sprint blah
blah = 'a' : _
```

Spines are evaluated independently of values

(NF) ‘normal form’ we mean that the expression is fully evaluated

(WHNF) ‘Weak head normal form’ means the expression is only evaluated as far as is 
necessary to reach a data constructor.

  : 
  /\ 
_   :
    /\ 
   _  :
      /\
     _ []

length is strict in the spine but not the values.

Exercises: Bottom Madness

Will it blow up?

1. [x^y | x <- [1..5], y <- [2, undefined]]
blowup
2. take 1 $ [ x ^ y | x <- [1..5], y <- [2, undefined] ]
works
3. sum [1, undefined, 3]
blowup
4. length [1, 2, undefined]
works 
5. length $ [1, 2, 3] ++ undefined
blowup
6. take 1 $ filter even [1, 2, 3, undefined]
works 
7. take 1 $ filter even [1, 3, undefined]
blowup
8. take 1 $ filter odd [1, 3, undefined]
works
9. take 2 $ filter odd [1, 3, undefined]
works
10. take 3 $ filter odd [1, 3, undefined]
blowup

Intermission: Is it in normal form?


1. [1, 2, 3, 4, 5]
NF
2. 1 : 2 : 3 : 4 : _
WHNF
3. enumFromTo 1 10
Neither
4. length [1, 2, 3, 4, 5]
Neither
5. sum (enumFromTo 1 10)
Neither
6. ['a'..'m'] ++ ['n'..'z']
Neither
7. (_, 'b')
WHNF

Transforming lists of values

use higher-order functions for transforming 
data rather than manually recursing over and over

map can only be used with []

fmap is defined in a typeclass named Functor and can be applied to
data other than lists

```
map :: (a->b)->[a]->[b]
fmap :: Functor f => (a -> b) -> f a -> f b
```

map doesn’t traverse the whole list and apply 
the function immediately. The function is
applied to the values you force out of the list one by one

“lazy in the spine, strict in the leaves.”

Exercises: More Bottoms

Will the following expression return a value or be ⊥?

1. take 1 $ map (+1) [undefined, 2, 3]

do not work

2. Will the following expression return a value?
take 1 $ map (+1) [1, undefined, 3]

yes [2]

3. Will the following expression return a value?
take 2 $ map (+1) [1, undefined, 3]

do not work

4. What does the following mystery function do? 
What is its type? Describe it (to yourself or a loved one) 
in standard English and then test it out in the REPL 
to make sure you were correct.

itIsMystery xs = map (\x -> elem x "aeiou") xs

retuns list of bools where each char of a string is a vowel

itIsMystery "stuff"
[False,False,True,False,False]

5. What will be the result of the following functions:
a) map (^2) [1..10]
list of 1..10 times itself

[1,4,9,16,25,36,49,64,81,100]

b) map minimum [[1..10], [10..20], [20..30]] 

the smallest list in the list - first list
[1..10]

-- n.b. `minimum` is not the same function -- as the `min` that we used before

c) map sum [[1..5], [1..5], [1..5]]

[15,15,15]

6. Back in chapter 7, you wrote a function called foldBool. 
That function exists in a module known as Data.Bool and is 
called bool. Write a function that does the same 
(or similar, if you wish) as the map (if-then-else) 
function you saw above but uses bool instead of the 
if-then-else syntax. Your first step should be bringing 
the bool function into scope by typing import Data.Bool 
at your Prelude prompt.

9.10 Filtering lists of values

```
filter :: (a -> Bool) -> [a] -> [a] 
filter _ [] = []
filter pred (x:xs)
 | pred x = x : filter pred xs 
 | otherwise = filter pred xs
```

Same function using filter and list comprehension
```
Prelude> filter (\x -> elem x "aeiou") "abracadabra"
"aaaaa"
Prelude> [x | x <- "abracadabra", elem x "aeiou"]
"aaaaa"
```

Exercises: Filtering

1. Giventheabove,howmightwewriteafilterfunction
thatwould give us all the multiples of 3 out of a list from 1-30?

filter (\x -> (rem x 3) == 0) [1..20]

2. Recalling what we learned about function 
composition, how could we compose the above 
function with the length function to tell us 
*how many* multiples of 3 there are between 1 and 30?

length $ filter (\x -> (rem x 3) == 0) [1..20]

3. Next we’re going to work on removing all articles 
(’the’, ’a’, and ’an’) from sentences. You want to get to 
something that works like this:

example   Prelude> myFilter "the brown dog was a goof"
 ["brown","dog","was","goof"]

```
myFilter :: String -> [String]
myFilter s = [x | x <- words s, notElem x ["the", "a", "same"]]
```

9.11 Zipping lists

```
Prelude> :t zip
zip :: [a] -> [b] -> [(a, b)]

Prelude> zip [1, 2, 3] [4, 5, 6]
[(1,4),(2,5),(3,6)]
```

One thing to note is that zip stops as soon 
as one of the lists runs out of values:


We can use unzip to recover the lists 
as they were before they were zipped:

```
zipWith :: (a -> b -> c)
```

We can also use zipWith to apply a function to the 
values of two lists in parallel:

```
zipWith (+) [1, 2, 3] [10, 11, 12]
```

```
zipWith (==) ['a'..'f'] ['a'..'m']
```

Zipping exercises

1. Write your own version of zip and ensure it 
behaves the same as the original.

```
myZip :: [a] -> [b] -> [(a, b)]
myZip [] _ = [] 
myZip _ [] = [] 
myZip (x:xs) (y:ys) = (x, y) : myZip xs ys

```

2. Do what you did for zip, but now for zipWith:

```
myZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
myZipWith _ [] _ = []
myZipWith _ _ [] = []
myZipWith f (x:xs) (y:ys) = f x y : myZipWith f xs ys
```

3. Rewrite your zip in terms of the zipWith you wrote.
```
myZip' :: [a] -> [b] -> [(a, b)]
myZip' = myZipWith (,)
```
9.12 Chapter Exercises

